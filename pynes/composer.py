# -*- coding: utf-8 -*-

import compiler
import ast
from re import match
from inspect import getmembers

import pynes.bitbag

from pynes.bitbag import PPU, Joypad, HardSprite
from pynes.nes_types import NesType, NesRs, NesArray, NesString, NesSprite, NesChrFile
from compiler import compile

class Game:

    ppu = PPU()

    def __init__(self):
        self._state = 'prog'
        self._asm_chunks = {}
        self.has_nmi = False

        self._header = {'.inesprg':1, '.ineschr':1,
            '.inesmap':0, '.inesmir':1}
        self._vars = {}
        self.bitpaks = {}

    def __add__(self, other):
        if other and isinstance(other, str):
            if self._state not in self._asm_chunks:
                self._asm_chunks[self._state] = other
            else:
                self._asm_chunks[self._state] += other
        return self

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        self._state = value
        self.prog = value + ':\n' 

    def headers(self):
        return '\n'.join(['%s %d\n' % (h, self._header[h])
            for h in ['.inesprg', '.ineschr', '.inesmap', '.inesmir']])

    def boot(self):
        asm_code =("  .org $FFFA\n"
             "  .dw %s\n"
             "  .dw %s\n"
             "  .dw 0\n"
            ) % (
            'NMI' if self.has_nmi else '0',
            'RESET' if 'reset' in self._asm_chunks else '0'
            )
        return asm_code

    def init(self):
        return (
          '  SEI          ; disable IRQs\n' +
          '  CLD          ; disable decimal mode\n' +
          '  LDX #$40\n' +
          '  STX $4017    ; disable APU frame IRQ\n' +
          '  LDX #$FF\n' +
          '  TXS          ; Set up stack\n' +
          '  INX          ; now X = 0\n' +
          '  STX $2000    ; disable NMI\n' +
          '  STX $2001    ; disable rendering\n' +
          '  STX $4010    ; disable DMC IRQs\n'
        )

    def rsset(self):
        asm_code = '\n'.join([
                '%s .rs %d' % (varname, var.size)
                for varname, var in self._vars.items()
                if isinstance(var, NesRs)
            ])
        if asm_code:
            return ("  .rsset $0000\n%s\n\n" % asm_code)
        return ""

    def infinity_loop(self):
        return (
          "InfiniteLoop:\n"
          "  JMP InfiniteLoop\n"
        )

    def prog(self):
        asm_code = ""
        if 'prog' in self._asm_chunks:
            asm_code += self._asm_chunks['prog'] 
        for bp in self.bitpaks:
            procedure = self.bitpaks[bp].procedure()
            if isinstance(procedure, str):
                asm_code += procedure + '\n'
        if 'reset' in self._asm_chunks:
            asm_code += self._asm_chunks['reset']
            asm_code += self.ppu.init()
            asm_code += self.infinity_loop()
        if len(asm_code) > 0:
            return ("  .bank 0\n  .org $C000\n\n" + asm_code +'\n\n')
        return ""

    def bank1(self):
        asm_code = ''. join(
            ['%s:\n%s' % (varname, var.to_asm())
            for varname, var in self._vars.items()
            if (isinstance (var,NesArray) or isinstance(var, NesSprite))])
        if asm_code:
            return ("  .bank 1\n  .org $E000\n\n" + asm_code + '\n\n')
        return ""

    def bank2(self):
        asm_code = '\n'.join(
            ['  .incbin "%s"' % var.filename
            for varname, var in self._vars.items()
            if isinstance(var, NesChrFile)
            ])

        if asm_code:
            return ("  .bank 2\n  .org $0000\n\n" + asm_code + '\n\n')
        return ""

    def nmi(self):
        joypad_1 = Joypad(1, self)
        joypad_2 = Joypad(2, self)
        joypad_code = ''
        if joypad_1.is_used:
            joypad_code += joypad_1.init()
            joypad_code += joypad_1.to_asm()
        if len(joypad_code) > 0 or self.has_nmi:
            self.has_nmi = True
            nmi_code = (
                "NMI:\n"
                "  LDA #$00\n"
                "  STA $2003 ; Write Only: Sets the offset in sprite ram.\n"
                "  LDA #$02\n"
                "  STA $4014 ; Write Only; DMA\n"
            )
            return nmi_code + joypad_code + "\n\n" + "  RTI   ;Return NMI\n"
        return ""

    def set_var(self, varname, value):
        self._vars[varname] = value

    def get_var(self, varname):
        return self._vars[varname]

    def to_asm(self):
        asm_code = (';Generated by PyNES\n\n' +
            self.headers() +
            self.rsset() +
            self.prog() +
            self.nmi() +
            self.bank1() +
            self.boot() +
            self.bank2()
            )
        return asm_code


class OperationStack:

    def __init__(self):
        self._stack = []
        self._pile = []

    def __call__(self, operand = None):
        if operand != None:
            self._stack.append(operand)
        return self._stack

    def store(self):
        if len(self._stack) > 0:
            self._pile.append(self._stack)
            self._stack = []

    def current(self):
        return self._stack

    def wipe(self):
        self._stack = []

    def last(self):
        if len(self._pile) > 0:
            return self._pile[-1]
        return [] #TODO if none breaks some len()

    def pendding(self):
        return self._pile

    def resolve(self):
        return self._pile.pop()

class PyNesVisitor(ast.NodeVisitor):

    def __init__(self):
        self.stack = OperationStack()

    def generic_visit(self, node, debug = False):
        if isinstance(node, list):
            for n in node:
                if debug:
                    print n
                self.visit(n)
        else:
            for field, value in reversed(list(ast.iter_fields(node))):
                if debug:
                    print value
                if isinstance(value, list):
                    for item in value:
                        if isinstance(item, ast.AST):
                            if debug:
                                print item
                            self.stack.store()
                            self.visit(item)
                elif isinstance(value, ast.AST):
                    self.visit(value)

    def visit_Import(self, node):
        pass

    def visit_If(self, node):
        if node.test.comparators[0].s == '__main__':
            pass
        else:
            print 'IF'
            print dir(node.test.comparators[0])
            print node.test.comparators[0].s

    def visit_AugAssign(self, node):
        self.generic_visit(node)
        if len(self.stack.current()) == 2 and len(self.stack.last()) == 2:
            if (isinstance(self.stack.last()[0], int) and
                isinstance(self.stack.last()[1], str) and #TODO op
                isinstance(self.stack.current()[0], HardSprite) and
                isinstance(self.stack.current()[1], str)): #TODO how to check
                

                address = getattr(self.stack.current()[0], self.stack.current()[1])
                self.stack.wipe()
                operation = self.stack.last()[1]
                operand = self.stack.resolve()
                global game
                game += '  LDA $%04x\n' % address
                if operation == '+':
                    game += '  CLC\n'
                    game += '  ADC #%d\n' % operand[0]
                elif operation == '-':
                    game += '  SEC\n'
                    game += '  SBC #%d\n' % operand[0]
                game += '  STA $%04x\n' % address

    def visit_Assign(self, node):
        global game
        if (len(node.targets) == 1):
            if isinstance(node.value, ast.Call):
                self.generic_visit(node)
                varname = node.targets[0].id
                call = node.value
                if call.func.id:
                    if (len(self.stack.last()) == 1 and
                        isinstance(self.stack.last()[0], NesType)):
                        rs = self.stack.resolve()[0]
                        self.stack.wipe()
                        game.set_var(varname, rs)
            elif isinstance(node.value, ast.List):
                self.generic_visit(node)
                #TODO: just umpile
                varname = node.targets[0].id
                assert isinstance(self.stack.last()[0], NesArray)
                assert varname == self.stack.current()[0]
                game.set_var(varname, NesArray(node.value.elts))
            elif isinstance(node.value, ast.Str):
                self.generic_visit(node)
                varname = node.targets[0].id
                assert isinstance(self.stack.last()[0], NesString)
                assert varname == self.stack.current()[0]
                value = self.stack.resolve()[0]
                self.stack.wipe()
                game.set_var(varname, value)
            elif 'ctx' in dir(node.targets[0]): #TODO fix this please
                self.generic_visit(node) #TODO: upthis
                if len(self.stack.last()) == 1 and isinstance(self.stack.last()[0], int):
                    game += '  LDA #%d\n' % self.stack.resolve()[0]
                if len(self.stack.current()) == 2:
                    address = getattr(self.stack.current()[0], self.stack.current()[1])
                    game += '  STA $%04x\n' % address

    def visit_List(self, node):
        self.stack(NesArray(node.elts))

    def visit_Attribute(self, node):
        self.generic_visit(node)
        attrib = node.attr
        self.stack(attrib)

    def visit_FunctionDef(self, node):
        global game
        game._state = node.name
        if 'reset' == node.name:
            game += node.name.upper() + ':\n'
            game += game.init()
            self.generic_visit(node)
        elif 'nmi' == node.name:
            game += node.name.upper() + ':\n'
            self.generic_visit(node)
        elif  match('^joypad[12]_(a|b|select|start|up|down|left|right)', node.name):
            game._state = node.name
            self.generic_visit(node)
        else:
            game += node.name.upper() + ':\n'
            game._state = node.name

    def visit_Call(self, node):
        global game
        if node.func.id:
            self.stack.store()
            if len(node.args) > 0:
                self.generic_visit(node.args)
                args = self.stack.current()
                self.stack.wipe()
            else:
                args = []
            if node.func.id not in game.bitpaks:
                obj = getattr(pynes.bitbag, node.func.id, None)
                if (obj):
                    try:
                        bp = obj(game)
                        game.bitpaks[node.func.id] = bp
                        self.stack(bp(*args))
                        game += bp.asm()
                    except TypeError, e:
                        msg = e.message.replace('__call__', node.func.id, 1)
                        raise(TypeError(msg))
                else:
                    raise(NameError("name '%s' is not defined" % node.func.id))
            else:
                bp = game.bitpaks[node.func.id]
                self.stack(bp(*args))
                game += bp.asm()

    def visit_Add(self, node):
        self.stack('+')

    def visit_Sub(self, node):
        self.stack('-')

    def visit_BinOp(self, node):
        if (isinstance(node.left, ast.Num) and
            isinstance(node.right, ast.Num)):
            a = node.left.n
            b = node.right.n
            self.stack(a + b)
        else:
            self.generic_visit(node)

    def visit_Str(self, node):
        self.stack(NesString(node.s))

    def visit_Num(self, node):
        self.stack(node.n)

    def visit_Name(self, node):
        if node.id in game._vars:
            value = game.get_var(node.id)
            value.instance_name = node.id
            self.stack(value)
        else:
            self.stack(node.id) #TODO

game = None

def compose_file(input, output=None, path=None, asm=False):
    from os.path import dirname, realpath

    f = open(input)
    code = f.read()
    f.close()

    if path == None:
        path = dirname(realpath(input)) + '/'

    game = compose(code)
    asmcode = game.to_asm()
    if asm:
        asmfile = open('output.asm', 'w')
        asmfile.write(asmcode)
        asmfile.close()
    compile(asmcode, 'output.nes', path)

def compose(code, game_program = game):
    global game
    if game_program == None:
        game = game_program = Game()

    python_land = ast.parse(code)
    turist = PyNesVisitor()
    turist.visit(python_land)
    game = None
    return game_program
