# -*- coding: utf-8 -*-

import compiler
import ast
from re import match
from inspect import getmembers

import pynes.bitbag

from pynes.bitbag import Joypad, HardSprite
from pynes.nes_types import NesType, NesRs, NesArray, NesSprite, NesChrFile

class Cartridge:

    def __init__(self):
        self._state = 'prog'
        self._asm_chunks = {}
        self.has_nmi = False

        self._header = {'.inesprg':1, '.ineschr':1,
            '.inesmap':0, '.inesmir':1}
        self._vars = {}
        self.bitpaks = {}

    def __add__(self, other):
        if other and isinstance(other, str):
            if self._state not in self._asm_chunks:
                self._asm_chunks[self._state] = other
            else:
                self._asm_chunks[self._state] += other
        return self

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        self._state = value
        self.prog = value + ':\n' 

    def headers(self):
        asm_code = ""
        for h in ['.inesprg', '.ineschr', '.inesmap', '.inesmir']:
            asm_code += h + ' ' + str(self._header[h]) + '\n'
        asm_code += '\n'
        return asm_code

    def boot(self):
        asm_code = "  .org $FFFA\n"

        if self.has_nmi:
            asm_code += '  .dw NMI\n'
        else:
            asm_code += '  .dw 0\n'
        
        if 'reset' in self._asm_chunks:
            asm_code += '  .dw RESET\n'
        else:
            asm_code += '  .dw 0\n'
        
        asm_code += '  .dw 0\n\n'

        return asm_code

    def init(self):
        return (
          '  SEI          ; disable IRQs\n' +
          '  CLD          ; disable decimal mode\n' +
          '  LDX #$40\n' +
          '  STX $4017    ; disable APU frame IRQ\n' +
          '  LDX #$FF\n' +
          '  TXS          ; Set up stack\n' +
          '  INX          ; now X = 0\n' +
          '  STX $2000    ; disable NMI\n' +
          '  STX $2001    ; disable rendering\n' +
          '  STX $4010    ; disable DMC IRQs\n'
        )

    def rsset(self):
        asm_code = ""
        for v in self._vars:
            if isinstance(self._vars[v], NesRs):
                asm_code += v + ' .rs ' + str(self._vars[v].size) + '\n'
        if len(asm_code) > 0:
            return ("  .rsset $0000\n" + asm_code + '\n\n')
        return ""

    def prog(self):
        asm_code = ""
        if 'prog' in self._asm_chunks:
            asm_code += self._asm_chunks['prog'] 
        for bp in self.bitpaks:
            procedure = self.bitpaks[bp].procedure()
            if isinstance(procedure, str):
                asm_code += procedure + '\n'
        if 'reset' in self._asm_chunks:
            asm_code += self._asm_chunks['reset']
        if len(asm_code) > 0:
            return ("  .bank 0\n  .org $C000\n\n" + asm_code + '\n\n')
        return ""

    def bank1(self):
        asm_code = ""
        for v in self._vars:
            if (isinstance(self._vars[v], NesArray) or
                isinstance(self._vars[v], NesSprite)):
                asm_code += v + ':\n' +self._vars[v].to_asm()
        if len(asm_code) > 0:
            return ("  .bank 1\n  .org $E000\n\n" + asm_code + '\n\n')
        return ""

    def bank2(self):
        asm_code = ""
        for v in self._vars:
            if isinstance(self._vars[v], NesChrFile):
                asm_code += '  .incbin "%s"' % self._vars[v].filename

        if len(asm_code) > 0:
            return ("  .bank 2\n  .org $0000\n\n" + asm_code + '\n\n')
        return ""

    def nmi(self):
        joypad_1 = Joypad(1, self)
        joypad_2 = Joypad(2, self)
        joypad_code = ''
        if joypad_1.is_used:
            joypad_code += joypad_1.init()
            joypad_code += joypad_1.to_asm()
        if len(joypad_code) > 0:
            self.has_nmi = True
            nmi_code = (
                "NMI:\n"
                "  LDA #$00\n"
                "  STA $2003 ; Write Only: Sets the offset in sprite ram.\n"
                "  LDA #$02\n"
                "  STA $4014 ; Write Only; DMA\n"
            )
            return nmi_code + joypad_code + "\n"
        return ""

    def set_var(self, varname, value):
        self._vars[varname] = value

    def get_var(self, varname):
        return self._vars[varname]

    def to_asm(self):
        asm_code = (';Generated by PyNES\n\n' +
            self.headers() +
            self.rsset() +
            self.prog() +
            self.nmi() +
            self.bank1() +
            self.boot() +
            self.bank2()
            )
        print asm_code
        return asm_code


class OperationStack:

    def __init__(self):
        self._stack = []
        self._pile = []

    def __call__(self, operand = None):
        if operand != None:
            self._stack.append(operand)
        return self._stack

    def store(self):
        if len(self._stack) > 0:
            self._pile.append(self._stack)
            self._stack = []

    def current(self):
        return self._stack

    def wipe(self):
        self._stack = []

    def last(self):
        if len(self._pile) > 0:
            return self._pile[-1]
        return [] #TODO if none breaks some len()

    def pendding(self):
        return self._pile

    def resolve(self):
        return self._pile.pop()

class PyNesVisitor(ast.NodeVisitor):

    def __init__(self):
        self.stack = OperationStack()

    def generic_visit(self, node, debug = False):
        if isinstance(node, list):
            for n in node:
                if debug:
                    print n
                self.visit(n)
        else:
            for field, value in reversed(list(ast.iter_fields(node))):
                if debug:
                    print value
                if isinstance(value, list):
                    for item in value:
                        if isinstance(item, ast.AST):
                            if debug:
                                print item
                            self.stack.store()
                            self.visit(item)
                elif isinstance(value, ast.AST):
                    self.visit(value)

    def visit_Import(self, node):
        pass

    def visit_If(self, node):
        if node.test.comparators[0].s == '__main__':
            pass
        else:
            print 'IF'
            print dir(node.test.comparators[0])
            print node.test.comparators[0].s

    def visit_AugAssign(self, node):
        self.generic_visit(node)
        if len(self.stack.current()) == 2 and len(self.stack.last()) == 2:
            if (isinstance(self.stack.last()[0], int) and
                isinstance(self.stack.last()[1], str) and #TODO op
                isinstance(self.stack.current()[0], HardSprite) and
                isinstance(self.stack.current()[1], str)): #TODO how to check
                address = getattr(self.stack.current()[0], self.stack.current()[1])
                self.stack.wipe()
                operand = self.stack.resolve()
                global cart
                cart += '  LDA $%04x\n' % address
                cart += '  CLC\n'
                cart += '  ADC #%d\n' % operand[0]
                cart += '  STA $%04x\n' % address

    def visit_Assign(self, node):
        global cart
        if (len(node.targets) == 1):
            if isinstance(node.value, ast.Call):
                self.generic_visit(node)
                varname = node.targets[0].id
                call = node.value
                if call.func.id:
                    if (len(self.stack.last()) == 1 and
                        isinstance(self.stack.last()[0], NesType)):
                        rs = self.stack.resolve()[0]
                        self.stack.wipe()
                        cart.set_var(varname, rs)
            elif isinstance(node.value, ast.List):
                self.generic_visit(node)
                #TODO: just umpile
                varname = node.targets[0].id
                cart.set_var(varname, NesArray(node.value.elts))
            elif 'ctx' in dir(node.targets[0]): #TODO fix this please
                self.generic_visit(node) #TODO: upthis
                if len(self.stack.last()) == 1 and isinstance(self.stack.last()[0], int):
                    cart += '  LDA #%d\n' % self.stack.resolve()[0]
                if len(self.stack.current()) == 2:
                    address = getattr(self.stack.current()[0], self.stack.current()[1])
                    cart += '  STA $%04x\n' % address

    def visit_List(self, node):
        self.stack(NesArray(node.elts))

    def visit_Attribute(self, node):
        self.generic_visit(node)
        attrib = node.attr
        self.stack(attrib)

    def visit_FunctionDef(self, node):
        global cart
        cart._state = node.name
        if 'reset' == node.name:
            cart += node.name.upper() + ':\n'
            cart += cart.init()
            self.generic_visit(node)
        elif 'nmi' == node.name:
            cart += node.name.upper() + ':\n'
            self.generic_visit(node)
        elif  match('^joypad[12]_(a|b|select|start|up|down|left|right)', node.name):
            cart._state = node.name
            self.generic_visit(node)
        else:
            cart += node.name.upper() + ':\n'
            cart._state = node.name

    def visit_Call(self, node):
        global cart
        if node.func.id:
            self.stack.store()
            if len(node.args) > 0:
                self.generic_visit(node.args)
                args = self.stack.current()
                self.stack.wipe()
            else:
                args = []
            if node.func.id not in cart.bitpaks:
                obj = getattr(pynes.bitbag, node.func.id, None)
                if (obj):
                    try:
                        bp = obj(cart)
                        cart.bitpaks[node.func.id] = bp
                        self.stack(bp(*args))
                        cart += bp.asm()
                    except TypeError, e:
                        msg = e.message.replace('__call__', node.func.id, 1)
                        raise(TypeError(msg))
                else:
                    raise(NameError("name '%s' is not defined" % node.func.id))
            else:
                bp = cart.bitpaks[node.func.id]
                self.stack(bp(*args))
                cart += bp.asm()

    def visit_Add(self, node):
        self.stack('+')

    def visit_Sub(self, node):
        self.stack('-')

    def visit_BinOp(self, node):
        if (isinstance(node.left, ast.Num) and
            isinstance(node.right, ast.Num)):
            a = node.left.n
            b = node.right.n
            self.stack(a + b)
        else:
            self.generic_visit(node)

    def visit_Num(self, node):
        self.stack(node.n)

    def visit_Name(self, node):
        if node.id in cart._vars:
            value = cart.get_var(node.id)
            value.instance_name = node.id
            self.stack(value)
        else:
            self.stack(node.id) #TODO

cart = None

def pynes_compiler(code, cartridge = cart):
    global cart
    if cartridge == None:
        cart = cartridge = Cartridge()

    python_land = ast.parse(code)
    turist = PyNesVisitor()
    turist.visit(python_land)
    cart = None
    return cartridge